/* automatically generated by rust-bindgen */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub const IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM: ib_uverbs_flow_action_esp_keymat = 0;
pub type ib_uverbs_flow_action_esp_keymat = u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE: ib_uverbs_flow_action_esp_replay = 0;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP: ib_uverbs_flow_action_esp_replay = 1;
pub type ib_uverbs_flow_action_esp_replay = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap {
    pub __bindgen_anon_1: ib_uverbs_flow_action_esp_encap__bindgen_ty_1,
    pub __bindgen_anon_2: ib_uverbs_flow_action_esp_encap__bindgen_ty_2,
    pub len: __u16,
    pub type_: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    pub val_ptr: *mut ::std::os::raw::c_void,
    pub val_ptr_data_u64: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>())).val_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>()))
                .val_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr_data_u64)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    pub next_ptr: *mut ib_uverbs_flow_action_esp_encap,
    pub next_ptr_data_u64: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>())).next_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>()))
                .next_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr_data_u64)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).type_ as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ib_uverbs_flow_action_esp {
    pub spi: __u32,
    pub seq: __u32,
    pub tfc_pad: __u32,
    pub flags: __u32,
    pub hard_limit_pkts: __u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).tfc_pad as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(tfc_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).hard_limit_pkts as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(hard_limit_pkts)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_gid {
    pub raw: [u8; 16usize],
    pub global: ibv_gid__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
#[test]
fn bindgen_test_layout_ibv_gid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_gid__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_gid__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).subnet_prefix as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(subnet_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).interface_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(interface_id)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_gid() {
    assert_eq!(
        ::std::mem::size_of::<ibv_gid>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_gid))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_gid>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_gid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_gid>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_gid>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid),
            "::",
            stringify!(global)
        )
    );
}
impl Default for ibv_gid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_NODE_UNKNOWN: ibv_node_type = -1;
pub const IBV_NODE_CA: ibv_node_type = 1;
pub const IBV_NODE_SWITCH: ibv_node_type = 2;
pub const IBV_NODE_ROUTER: ibv_node_type = 3;
pub const IBV_NODE_RNIC: ibv_node_type = 4;
pub const IBV_NODE_USNIC: ibv_node_type = 5;
pub const IBV_NODE_USNIC_UDP: ibv_node_type = 6;
pub type ibv_node_type = i32;
pub const IBV_TRANSPORT_UNKNOWN: ibv_transport_type = -1;
pub const IBV_TRANSPORT_IB: ibv_transport_type = 0;
pub const IBV_TRANSPORT_IWARP: ibv_transport_type = 1;
pub const IBV_TRANSPORT_USNIC: ibv_transport_type = 2;
pub const IBV_TRANSPORT_USNIC_UDP: ibv_transport_type = 3;
pub type ibv_transport_type = i32;
pub const IBV_DEVICE_RESIZE_MAX_WR: ibv_device_cap_flags = 1;
pub const IBV_DEVICE_BAD_PKEY_CNTR: ibv_device_cap_flags = 2;
pub const IBV_DEVICE_BAD_QKEY_CNTR: ibv_device_cap_flags = 4;
pub const IBV_DEVICE_RAW_MULTI: ibv_device_cap_flags = 8;
pub const IBV_DEVICE_AUTO_PATH_MIG: ibv_device_cap_flags = 16;
pub const IBV_DEVICE_CHANGE_PHY_PORT: ibv_device_cap_flags = 32;
pub const IBV_DEVICE_UD_AV_PORT_ENFORCE: ibv_device_cap_flags = 64;
pub const IBV_DEVICE_CURR_QP_STATE_MOD: ibv_device_cap_flags = 128;
pub const IBV_DEVICE_SHUTDOWN_PORT: ibv_device_cap_flags = 256;
pub const IBV_DEVICE_INIT_TYPE: ibv_device_cap_flags = 512;
pub const IBV_DEVICE_PORT_ACTIVE_EVENT: ibv_device_cap_flags = 1024;
pub const IBV_DEVICE_SYS_IMAGE_GUID: ibv_device_cap_flags = 2048;
pub const IBV_DEVICE_RC_RNR_NAK_GEN: ibv_device_cap_flags = 4096;
pub const IBV_DEVICE_SRQ_RESIZE: ibv_device_cap_flags = 8192;
pub const IBV_DEVICE_N_NOTIFY_CQ: ibv_device_cap_flags = 16384;
pub const IBV_DEVICE_MEM_WINDOW: ibv_device_cap_flags = 131072;
pub const IBV_DEVICE_UD_IP_CSUM: ibv_device_cap_flags = 262144;
pub const IBV_DEVICE_XRC: ibv_device_cap_flags = 1048576;
pub const IBV_DEVICE_MEM_MGT_EXTENSIONS: ibv_device_cap_flags = 2097152;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2A: ibv_device_cap_flags = 8388608;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2B: ibv_device_cap_flags = 16777216;
pub const IBV_DEVICE_RC_IP_CSUM: ibv_device_cap_flags = 33554432;
pub const IBV_DEVICE_RAW_IP_CSUM: ibv_device_cap_flags = 67108864;
pub const IBV_DEVICE_MANAGED_FLOW_STEERING: ibv_device_cap_flags = 536870912;
pub type ibv_device_cap_flags = u32;
pub const IBV_ATOMIC_NONE: ibv_atomic_cap = 0;
pub const IBV_ATOMIC_HCA: ibv_atomic_cap = 1;
pub const IBV_ATOMIC_GLOB: ibv_atomic_cap = 2;
pub type ibv_atomic_cap = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_alloc_dm_attr {
    pub length: usize,
    pub log_align_req: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_alloc_dm_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_alloc_dm_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_alloc_dm_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).log_align_req as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(log_align_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).comp_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: ::std::option::Option<
        unsafe extern "C" fn(
            dm: *mut ibv_dm,
            dm_offset: u64,
            host_addr: *const ::std::os::raw::c_void,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub memcpy_from_dm: ::std::option::Option<
        unsafe extern "C" fn(
            host_addr: *mut ::std::os::raw::c_void,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_dm() {
    assert_eq!(
        ::std::mem::size_of::<ibv_dm>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_dm))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_dm>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_dm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_to_dm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_to_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_from_dm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_from_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).comp_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_dm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
#[test]
fn bindgen_test_layout_ibv_device_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr>(),
        232usize,
        concat!("Size of: ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).fw_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(fw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).node_guid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(node_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).sys_image_guid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(sys_image_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).page_size_cap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(page_size_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_part_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_part_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).hw_ver as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(hw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_wr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_wr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).device_cap_flags as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(device_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge_rd as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge_rd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cqe as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pd as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_rd_atom as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_rd_atom as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_res_rd_atom as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_res_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_init_rd_atom as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_init_rd_atom as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).atomic_cap as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(atomic_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_rdd as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_rdd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mw as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ipv6_qp as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ipv6_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ethy_qp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ethy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_grp as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_grp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_qp_attach as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_total_mcast_qp_attach as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_total_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ah as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ah)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_fmr as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_map_per_fmr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_map_per_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_wr as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_sge as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pkeys as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pkeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).local_ca_ack_delay as *const _ as usize
        },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(local_ca_ack_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).phys_port_cnt as *const _ as usize },
        227usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(phys_port_cnt)
        )
    );
}
impl Default for ibv_device_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_query_device_ex_input() {
    assert_eq!(
        ::std::mem::size_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_query_device_ex_input>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_query_device_ex_input),
            "::",
            stringify!(comp_mask)
        )
    );
}
pub const IBV_ODP_SUPPORT_SEND: ibv_odp_transport_cap_bits = 1;
pub const IBV_ODP_SUPPORT_RECV: ibv_odp_transport_cap_bits = 2;
pub const IBV_ODP_SUPPORT_WRITE: ibv_odp_transport_cap_bits = 4;
pub const IBV_ODP_SUPPORT_READ: ibv_odp_transport_cap_bits = 8;
pub const IBV_ODP_SUPPORT_ATOMIC: ibv_odp_transport_cap_bits = 16;
pub type ibv_odp_transport_cap_bits = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
#[test]
fn bindgen_test_layout_ibv_odp_caps__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).rc_odp_caps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(rc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).uc_odp_caps as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(uc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).ud_odp_caps as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(ud_odp_caps)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_odp_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).general_caps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(general_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).per_transport_caps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(per_transport_caps)
        )
    );
}
pub const IBV_ODP_SUPPORT: ibv_odp_general_caps = 1;
pub type ibv_odp_general_caps = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_tso_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tso_caps>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tso_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).max_tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(max_tso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).supported_qpts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
pub const IBV_RX_HASH_FUNC_TOEPLITZ: ibv_rx_hash_function_flags = 1;
pub type ibv_rx_hash_function_flags = u32;
pub const IBV_RX_HASH_SRC_IPV4: ibv_rx_hash_fields = 1;
pub const IBV_RX_HASH_DST_IPV4: ibv_rx_hash_fields = 2;
pub const IBV_RX_HASH_SRC_IPV6: ibv_rx_hash_fields = 4;
pub const IBV_RX_HASH_DST_IPV6: ibv_rx_hash_fields = 8;
pub const IBV_RX_HASH_SRC_PORT_TCP: ibv_rx_hash_fields = 16;
pub const IBV_RX_HASH_DST_PORT_TCP: ibv_rx_hash_fields = 32;
pub const IBV_RX_HASH_SRC_PORT_UDP: ibv_rx_hash_fields = 64;
pub const IBV_RX_HASH_DST_PORT_UDP: ibv_rx_hash_fields = 128;
pub const IBV_RX_HASH_IPSEC_SPI: ibv_rx_hash_fields = 256;
pub const IBV_RX_HASH_INNER: ibv_rx_hash_fields = 2147483648;
pub type ibv_rx_hash_fields = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[test]
fn bindgen_test_layout_ibv_rss_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rss_caps>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rss_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).supported_qpts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_tables as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_table_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_table_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_function)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_packet_pacing_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_packet_pacing_caps>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_packet_pacing_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_max as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).supported_qpts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
pub const IBV_RAW_PACKET_CAP_CVLAN_STRIPPING: ibv_raw_packet_caps = 1;
pub const IBV_RAW_PACKET_CAP_SCATTER_FCS: ibv_raw_packet_caps = 2;
pub const IBV_RAW_PACKET_CAP_IP_CSUM: ibv_raw_packet_caps = 4;
pub const IBV_RAW_PACKET_CAP_DELAY_DROP: ibv_raw_packet_caps = 8;
pub type ibv_raw_packet_caps = u32;
pub const IBV_TM_CAP_RC: ibv_tm_cap_flags = 1;
pub type ibv_tm_cap_flags = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_caps>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_rndv_hdr_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_rndv_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_num_tags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_ops as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_sge)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_cq_moderation_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_moderation_caps>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_moderation_caps>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_period as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_period)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
}
#[test]
fn bindgen_test_layout_ibv_device_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr_ex>(),
        384usize,
        concat!("Size of: ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).orig_attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(orig_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).comp_mask as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).odp_caps as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).completion_timestamp_mask as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(completion_timestamp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).hca_core_clock as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(hca_core_clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).device_cap_flags_ex as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(device_cap_flags_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tso_caps as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tso_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).rss_caps as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(rss_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_wq_type_rq as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_wq_type_rq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).packet_pacing_caps as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(packet_pacing_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).raw_packet_caps as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(raw_packet_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tm_caps as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tm_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).cq_mod_caps as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(cq_mod_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_dm_size as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_dm_size)
        )
    );
}
impl Default for ibv_device_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_MTU_256: ibv_mtu = 1;
pub const IBV_MTU_512: ibv_mtu = 2;
pub const IBV_MTU_1024: ibv_mtu = 3;
pub const IBV_MTU_2048: ibv_mtu = 4;
pub const IBV_MTU_4096: ibv_mtu = 5;
pub type ibv_mtu = u32;
pub mod ibv_port_state {
    pub type Type = u32;
    pub const IBV_PORT_NOP: Type = 0;
    pub const IBV_PORT_DOWN: Type = 1;
    pub const IBV_PORT_INIT: Type = 2;
    pub const IBV_PORT_ARMED: Type = 3;
    pub const IBV_PORT_ACTIVE: Type = 4;
    pub const IBV_PORT_ACTIVE_DEFER: Type = 5;
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SM: ibv_port_cap_flags = ibv_port_cap_flags(2);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_OPT_IPD_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_AUTO_MIGR_SUP: ibv_port_cap_flags = ibv_port_cap_flags(32);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SL_MAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(64);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_MKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(128);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(256);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LED_INFO_SUP: ibv_port_cap_flags = ibv_port_cap_flags(512);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SYS_IMAGE_GUID_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2048);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4096);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_EXTENDED_SPEEDS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16384);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CM_SUP: ibv_port_cap_flags = ibv_port_cap_flags(65536);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SNMP_TUNNEL_SUP: ibv_port_cap_flags = ibv_port_cap_flags(131072);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_REINIT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(262144);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DEVICE_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(524288);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_VENDOR_CLASS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(1048576);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DR_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2097152);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CAP_MASK_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4194304);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_BOOT_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8388608);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LINK_LATENCY_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16777216);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CLIENT_REG_SUP: ibv_port_cap_flags = ibv_port_cap_flags(33554432);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_IP_BASED_GIDS: ibv_port_cap_flags = ibv_port_cap_flags(67108864);
}
impl ::std::ops::BitOr<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_port_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_port_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ibv_port_cap_flags(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_port_attr {
    pub state: ibv_port_state::Type,
    pub max_mtu: ibv_mtu,
    pub active_mtu: ibv_mtu,
    pub gid_tbl_len: ::std::os::raw::c_int,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub reserved: u8,
}
#[test]
fn bindgen_test_layout_ibv_port_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_port_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_port_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_mtu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).gid_tbl_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(gid_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).port_cap_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(port_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_msg_sz as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_msg_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).bad_pkey_cntr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(bad_pkey_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).qkey_viol_cntr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(qkey_viol_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).pkey_tbl_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(pkey_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_lid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lmc as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lmc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_vl_num as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_vl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_sl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).subnet_timeout as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(subnet_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).init_type_reply as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(init_type_reply)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_width as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_speed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).phys_state as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(phys_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).link_layer as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(link_layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).reserved as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for ibv_port_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_EVENT_CQ_ERR: ibv_event_type = 0;
pub const IBV_EVENT_QP_FATAL: ibv_event_type = 1;
pub const IBV_EVENT_QP_REQ_ERR: ibv_event_type = 2;
pub const IBV_EVENT_QP_ACCESS_ERR: ibv_event_type = 3;
pub const IBV_EVENT_COMM_EST: ibv_event_type = 4;
pub const IBV_EVENT_SQ_DRAINED: ibv_event_type = 5;
pub const IBV_EVENT_PATH_MIG: ibv_event_type = 6;
pub const IBV_EVENT_PATH_MIG_ERR: ibv_event_type = 7;
pub const IBV_EVENT_DEVICE_FATAL: ibv_event_type = 8;
pub const IBV_EVENT_PORT_ACTIVE: ibv_event_type = 9;
pub const IBV_EVENT_PORT_ERR: ibv_event_type = 10;
pub const IBV_EVENT_LID_CHANGE: ibv_event_type = 11;
pub const IBV_EVENT_PKEY_CHANGE: ibv_event_type = 12;
pub const IBV_EVENT_SM_CHANGE: ibv_event_type = 13;
pub const IBV_EVENT_SRQ_ERR: ibv_event_type = 14;
pub const IBV_EVENT_SRQ_LIMIT_REACHED: ibv_event_type = 15;
pub const IBV_EVENT_QP_LAST_WQE_REACHED: ibv_event_type = 16;
pub const IBV_EVENT_CLIENT_REREGISTER: ibv_event_type = 17;
pub const IBV_EVENT_GID_CHANGE: ibv_event_type = 18;
pub const IBV_EVENT_WQ_FATAL: ibv_event_type = 19;
pub type ibv_event_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_async_event {
    pub element: ibv_async_event__bindgen_ty_1,
    pub event_type: ibv_event_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_async_event__bindgen_ty_1 {
    pub cq: *mut ibv_cq,
    pub qp: *mut ibv_qp,
    pub srq: *mut ibv_srq,
    pub wq: *mut ibv_wq,
    pub port_num: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ibv_async_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).cq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).qp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).srq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).wq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).port_num as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(port_num)
        )
    );
}
impl Default for ibv_async_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_async_event() {
    assert_eq!(
        ::std::mem::size_of::<ibv_async_event>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_async_event))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_async_event>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_async_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_async_event>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_async_event>())).event_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event),
            "::",
            stringify!(event_type)
        )
    );
}
impl Default for ibv_async_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_wc_status {
    pub type Type = u32;
    pub const IBV_WC_SUCCESS: Type = 0;
    pub const IBV_WC_LOC_LEN_ERR: Type = 1;
    pub const IBV_WC_LOC_QP_OP_ERR: Type = 2;
    pub const IBV_WC_LOC_EEC_OP_ERR: Type = 3;
    pub const IBV_WC_LOC_PROT_ERR: Type = 4;
    pub const IBV_WC_WR_FLUSH_ERR: Type = 5;
    pub const IBV_WC_MW_BIND_ERR: Type = 6;
    pub const IBV_WC_BAD_RESP_ERR: Type = 7;
    pub const IBV_WC_LOC_ACCESS_ERR: Type = 8;
    pub const IBV_WC_REM_INV_REQ_ERR: Type = 9;
    pub const IBV_WC_REM_ACCESS_ERR: Type = 10;
    pub const IBV_WC_REM_OP_ERR: Type = 11;
    pub const IBV_WC_RETRY_EXC_ERR: Type = 12;
    pub const IBV_WC_RNR_RETRY_EXC_ERR: Type = 13;
    pub const IBV_WC_LOC_RDD_VIOL_ERR: Type = 14;
    pub const IBV_WC_REM_INV_RD_REQ_ERR: Type = 15;
    pub const IBV_WC_REM_ABORT_ERR: Type = 16;
    pub const IBV_WC_INV_EECN_ERR: Type = 17;
    pub const IBV_WC_INV_EEC_STATE_ERR: Type = 18;
    pub const IBV_WC_FATAL_ERR: Type = 19;
    pub const IBV_WC_RESP_TIMEOUT_ERR: Type = 20;
    pub const IBV_WC_GENERAL_ERR: Type = 21;
    pub const IBV_WC_TM_ERR: Type = 22;
    pub const IBV_WC_TM_RNDV_INCOMPLETE: Type = 23;
}
extern "C" {
    pub fn ibv_wc_status_str(status: ibv_wc_status::Type) -> *const ::std::os::raw::c_char;
}
pub mod ibv_wc_opcode {
    pub type Type = u32;
    pub const IBV_WC_SEND: Type = 0;
    pub const IBV_WC_RDMA_WRITE: Type = 1;
    pub const IBV_WC_RDMA_READ: Type = 2;
    pub const IBV_WC_COMP_SWAP: Type = 3;
    pub const IBV_WC_FETCH_ADD: Type = 4;
    pub const IBV_WC_BIND_MW: Type = 5;
    pub const IBV_WC_LOCAL_INV: Type = 6;
    pub const IBV_WC_TSO: Type = 7;
    pub const IBV_WC_RECV: Type = 128;
    pub const IBV_WC_RECV_RDMA_WITH_IMM: Type = 129;
    pub const IBV_WC_TM_ADD: Type = 130;
    pub const IBV_WC_TM_DEL: Type = 131;
    pub const IBV_WC_TM_SYNC: Type = 132;
    pub const IBV_WC_TM_RECV: Type = 133;
    pub const IBV_WC_TM_NO_TAG: Type = 134;
}
pub const IBV_WC_EX_WITH_BYTE_LEN: ibv_create_cq_wc_flags = 1;
pub const IBV_WC_EX_WITH_IMM: ibv_create_cq_wc_flags = 2;
pub const IBV_WC_EX_WITH_QP_NUM: ibv_create_cq_wc_flags = 4;
pub const IBV_WC_EX_WITH_SRC_QP: ibv_create_cq_wc_flags = 8;
pub const IBV_WC_EX_WITH_SLID: ibv_create_cq_wc_flags = 16;
pub const IBV_WC_EX_WITH_SL: ibv_create_cq_wc_flags = 32;
pub const IBV_WC_EX_WITH_DLID_PATH_BITS: ibv_create_cq_wc_flags = 64;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP: ibv_create_cq_wc_flags = 128;
pub const IBV_WC_EX_WITH_CVLAN: ibv_create_cq_wc_flags = 256;
pub const IBV_WC_EX_WITH_FLOW_TAG: ibv_create_cq_wc_flags = 512;
pub const IBV_WC_EX_WITH_TM_INFO: ibv_create_cq_wc_flags = 1024;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP_WALLCLOCK: ibv_create_cq_wc_flags = 2048;
pub type ibv_create_cq_wc_flags = u32;
impl ibv_wc_flags {
    pub const IBV_WC_GRH: ibv_wc_flags = ibv_wc_flags(1);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_IMM: ibv_wc_flags = ibv_wc_flags(2);
}
impl ibv_wc_flags {
    pub const IBV_WC_IP_CSUM_OK: ibv_wc_flags = ibv_wc_flags(4);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_INV: ibv_wc_flags = ibv_wc_flags(8);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_SYNC_REQ: ibv_wc_flags = ibv_wc_flags(16);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_MATCH: ibv_wc_flags = ibv_wc_flags(32);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_DATA_VALID: ibv_wc_flags = ibv_wc_flags(64);
}
impl ::std::ops::BitOr<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wc_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wc_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wc_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wc_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ibv_wc_flags(pub u32);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status::Type,
    pub opcode: ibv_wc_opcode::Type,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).imm_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).invalidated_rkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(invalidated_rkey)
        )
    );
}
impl Default for ibv_wc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_wc() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_wc))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).opcode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).vendor_err as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(vendor_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).byte_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).qp_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).src_qp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(src_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).wc_flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).pkey_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).slid as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).sl as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).dlid_path_bits as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(dlid_path_bits)
        )
    );
}
impl Default for ibv_wc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_access_flags {
    pub const IBV_ACCESS_LOCAL_WRITE: ibv_access_flags = ibv_access_flags(1);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_WRITE: ibv_access_flags = ibv_access_flags(2);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_READ: ibv_access_flags = ibv_access_flags(4);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_ATOMIC: ibv_access_flags = ibv_access_flags(8);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_MW_BIND: ibv_access_flags = ibv_access_flags(16);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ZERO_BASED: ibv_access_flags = ibv_access_flags(32);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ON_DEMAND: ibv_access_flags = ibv_access_flags(64);
}
impl ::std::ops::BitOr<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_access_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_access_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_access_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_access_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_access_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_access_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ibv_access_flags(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ibv_mw_bind_info() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw_bind_info>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_mw_bind_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw_bind_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw_bind_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).mr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_mw_bind_info>())).mw_access_flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(mw_access_flags)
        )
    );
}
impl Default for ibv_mw_bind_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_pd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_pd>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_pd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_pd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_pd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_pd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_td_init_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_td_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_td {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_td() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_td))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_td))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_td {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_XRCD_INIT_ATTR_FD: ibv_xrcd_init_attr_mask = 1;
pub const IBV_XRCD_INIT_ATTR_OFLAGS: ibv_xrcd_init_attr_mask = 2;
pub const IBV_XRCD_INIT_ATTR_RESERVED: ibv_xrcd_init_attr_mask = 4;
pub type ibv_xrcd_init_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_xrcd_init_attr {
    pub comp_mask: u32,
    pub fd: ::std::os::raw::c_int,
    pub oflags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_xrcd_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd_init_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).oflags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(oflags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_xrcd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_xrcd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_REREG_MR_CHANGE_TRANSLATION: ibv_rereg_mr_flags = 1;
pub const IBV_REREG_MR_CHANGE_PD: ibv_rereg_mr_flags = 2;
pub const IBV_REREG_MR_CHANGE_ACCESS: ibv_rereg_mr_flags = 4;
pub const IBV_REREG_MR_KEEP_VALID: ibv_rereg_mr_flags = 8;
pub const IBV_REREG_MR_FLAGS_SUPPORTED: ibv_rereg_mr_flags = 15;
pub type ibv_rereg_mr_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_mr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).handle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).lkey as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(lkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).rkey as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(rkey)
        )
    );
}
impl Default for ibv_mr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_MW_TYPE_1: ibv_mw_type = 1;
pub const IBV_MW_TYPE_2: ibv_mw_type = 2;
pub type ibv_mw_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type,
}
#[test]
fn bindgen_test_layout_ibv_mw() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_mw))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).rkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).handle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for ibv_mw {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_global_route {
    pub dgid: ibv_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
}
#[test]
fn bindgen_test_layout_ibv_global_route() {
    assert_eq!(
        ::std::mem::size_of::<ibv_global_route>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_global_route))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_global_route>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_global_route))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).dgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).flow_label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).sgid_index as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(sgid_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).hop_limit as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).traffic_class as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(traffic_class)
        )
    );
}
impl Default for ibv_global_route {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_grh {
    pub version_tclass_flow: __be32,
    pub paylen: __be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
}
#[test]
fn bindgen_test_layout_ibv_grh() {
    assert_eq!(
        ::std::mem::size_of::<ibv_grh>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_grh))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_grh>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_grh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).version_tclass_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(version_tclass_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).paylen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(paylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).next_hdr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).hop_limit as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).sgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).dgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(dgid)
        )
    );
}
impl Default for ibv_grh {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_RATE_MAX: ibv_rate = 0;
pub const IBV_RATE_2_5_GBPS: ibv_rate = 2;
pub const IBV_RATE_5_GBPS: ibv_rate = 5;
pub const IBV_RATE_10_GBPS: ibv_rate = 3;
pub const IBV_RATE_20_GBPS: ibv_rate = 6;
pub const IBV_RATE_30_GBPS: ibv_rate = 4;
pub const IBV_RATE_40_GBPS: ibv_rate = 7;
pub const IBV_RATE_60_GBPS: ibv_rate = 8;
pub const IBV_RATE_80_GBPS: ibv_rate = 9;
pub const IBV_RATE_120_GBPS: ibv_rate = 10;
pub const IBV_RATE_14_GBPS: ibv_rate = 11;
pub const IBV_RATE_56_GBPS: ibv_rate = 12;
pub const IBV_RATE_112_GBPS: ibv_rate = 13;
pub const IBV_RATE_168_GBPS: ibv_rate = 14;
pub const IBV_RATE_25_GBPS: ibv_rate = 15;
pub const IBV_RATE_100_GBPS: ibv_rate = 16;
pub const IBV_RATE_200_GBPS: ibv_rate = 17;
pub const IBV_RATE_300_GBPS: ibv_rate = 18;
pub type ibv_rate = u32;
extern "C" {
    /// ibv_rate_to_mult - Convert the IB rate enum to a multiple of the
    /// base rate of 2.5 Gbit/sec.  For example, IBV_RATE_5_GBPS will be
    /// converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.
    /// @rate: rate to convert.
    pub fn ibv_rate_to_mult(rate: ibv_rate) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_rate_to_mbps - Convert the IB rate enum to Mbit/sec.
    /// For example, IBV_RATE_5_GBPS will return the value 5000.
    /// @rate: rate to convert.
    pub fn ibv_rate_to_mbps(rate: ibv_rate) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah_attr {
    pub grh: ibv_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
#[test]
fn bindgen_test_layout_ibv_ah_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ah_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_ah_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ah_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ah_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).grh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(grh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).dlid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).sl as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).src_path_bits as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(src_path_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).static_rate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(static_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).is_global as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(is_global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).port_num as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(port_num)
        )
    );
}
impl Default for ibv_ah_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_SRQ_MAX_WR: ibv_srq_attr_mask = 1;
pub const IBV_SRQ_LIMIT: ibv_srq_attr_mask = 2;
pub type ibv_srq_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_sge as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).srq_limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(srq_limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).srq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for ibv_srq_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_SRQT_BASIC: ibv_srq_type = 0;
pub const IBV_SRQT_XRC: ibv_srq_type = 1;
pub const IBV_SRQT_TM: ibv_srq_type = 2;
pub type ibv_srq_type = u32;
pub const IBV_SRQ_INIT_ATTR_TYPE: ibv_srq_init_attr_mask = 1;
pub const IBV_SRQ_INIT_ATTR_PD: ibv_srq_init_attr_mask = 2;
pub const IBV_SRQ_INIT_ATTR_XRCD: ibv_srq_init_attr_mask = 4;
pub const IBV_SRQ_INIT_ATTR_CQ: ibv_srq_init_attr_mask = 8;
pub const IBV_SRQ_INIT_ATTR_TM: ibv_srq_init_attr_mask = 16;
pub const IBV_SRQ_INIT_ATTR_RESERVED: ibv_srq_init_attr_mask = 32;
pub type ibv_srq_init_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tm_cap {
    pub max_num_tags: u32,
    pub max_ops: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_cap>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_num_tags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr_ex {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
    pub comp_mask: u32,
    pub srq_type: ibv_srq_type,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub cq: *mut ibv_cq,
    pub tm_cap: ibv_tm_cap,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr_ex>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_context as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).comp_mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).pd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).xrcd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).cq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).tm_cap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(tm_cap)
        )
    );
}
impl Default for ibv_srq_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_WQT_RQ: ibv_wq_type = 0;
pub type ibv_wq_type = u32;
pub const IBV_WQ_INIT_ATTR_FLAGS: ibv_wq_init_attr_mask = 1;
pub const IBV_WQ_INIT_ATTR_RESERVED: ibv_wq_init_attr_mask = 2;
pub type ibv_wq_init_attr_mask = u32;
pub const IBV_WQ_FLAGS_CVLAN_STRIPPING: ibv_wq_flags = 1;
pub const IBV_WQ_FLAGS_SCATTER_FCS: ibv_wq_flags = 2;
pub const IBV_WQ_FLAGS_DELAY_DROP: ibv_wq_flags = 4;
pub const IBV_WQ_FLAGS_PCI_WRITE_END_PADDING: ibv_wq_flags = 8;
pub const IBV_WQ_FLAGS_RESERVED: ibv_wq_flags = 16;
pub type ibv_wq_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut ::std::os::raw::c_void,
    pub wq_type: ibv_wq_type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_init_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_wr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).pd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).create_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(create_flags)
        )
    );
}
impl Default for ibv_wq_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_WQS_RESET: ibv_wq_state = 0;
pub const IBV_WQS_RDY: ibv_wq_state = 1;
pub const IBV_WQS_ERR: ibv_wq_state = 2;
pub const IBV_WQS_UNKNOWN: ibv_wq_state = 3;
pub type ibv_wq_state = u32;
pub const IBV_WQ_ATTR_STATE: ibv_wq_attr_mask = 1;
pub const IBV_WQ_ATTR_CURR_STATE: ibv_wq_attr_mask = 2;
pub const IBV_WQ_ATTR_FLAGS: ibv_wq_attr_mask = 4;
pub const IBV_WQ_ATTR_RESERVED: ibv_wq_attr_mask = 8;
pub type ibv_wq_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state,
    pub curr_wq_state: ibv_wq_state,
    pub flags: u32,
    pub flags_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).wq_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).curr_wq_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(curr_wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags_mask)
        )
    );
}
impl Default for ibv_wq_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: ::std::os::raw::c_int,
    pub ind_tbl_num: ::std::os::raw::c_int,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_num as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).comp_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_rwq_ind_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_CREATE_IND_TABLE_RESERVED: ibv_ind_table_init_attr_mask = 1;
pub type ibv_ind_table_init_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).log_ind_tbl_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(log_ind_tbl_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).ind_tbl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_rwq_ind_table_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_qp_type {
    pub type Type = u32;
    pub const IBV_QPT_RC: Type = 2;
    pub const IBV_QPT_UC: Type = 3;
    pub const IBV_QPT_UD: Type = 4;
    pub const IBV_QPT_RAW_PACKET: Type = 8;
    pub const IBV_QPT_XRC_SEND: Type = 9;
    pub const IBV_QPT_XRC_RECV: Type = 10;
    pub const IBV_QPT_DRIVER: Type = 255;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_cap>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_wr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_sge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_sge as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_inline_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_inline_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(sq_sig_all)
        )
    );
}
impl Default for ibv_qp_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_QP_INIT_ATTR_PD: ibv_qp_init_attr_mask = 1;
pub const IBV_QP_INIT_ATTR_XRCD: ibv_qp_init_attr_mask = 2;
pub const IBV_QP_INIT_ATTR_CREATE_FLAGS: ibv_qp_init_attr_mask = 4;
pub const IBV_QP_INIT_ATTR_MAX_TSO_HEADER: ibv_qp_init_attr_mask = 8;
pub const IBV_QP_INIT_ATTR_IND_TABLE: ibv_qp_init_attr_mask = 16;
pub const IBV_QP_INIT_ATTR_RX_HASH: ibv_qp_init_attr_mask = 32;
pub const IBV_QP_INIT_ATTR_RESERVED: ibv_qp_init_attr_mask = 64;
pub type ibv_qp_init_attr_mask = u32;
pub const IBV_QP_CREATE_BLOCK_SELF_MCAST_LB: ibv_qp_create_flags = 2;
pub const IBV_QP_CREATE_SCATTER_FCS: ibv_qp_create_flags = 256;
pub const IBV_QP_CREATE_CVLAN_STRIPPING: ibv_qp_create_flags = 512;
pub const IBV_QP_CREATE_SOURCE_QPN: ibv_qp_create_flags = 1024;
pub const IBV_QP_CREATE_PCI_WRITE_END_PADDING: ibv_qp_create_flags = 2048;
pub type ibv_qp_create_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_rx_hash_conf() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rx_hash_conf>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rx_hash_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
}
impl Default for ibv_rx_hash_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr_ex>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(sq_sig_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).comp_mask as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).pd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).xrcd as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).create_flags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(create_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).max_tso_header as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(max_tso_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rwq_ind_tbl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rwq_ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rx_hash_conf as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rx_hash_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).source_qpn as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(source_qpn)
        )
    );
}
impl Default for ibv_qp_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_QP_OPEN_ATTR_NUM: ibv_qp_open_attr_mask = 1;
pub const IBV_QP_OPEN_ATTR_XRCD: ibv_qp_open_attr_mask = 2;
pub const IBV_QP_OPEN_ATTR_CONTEXT: ibv_qp_open_attr_mask = 4;
pub const IBV_QP_OPEN_ATTR_TYPE: ibv_qp_open_attr_mask = 8;
pub const IBV_QP_OPEN_ATTR_RESERVED: ibv_qp_open_attr_mask = 16;
pub type ibv_qp_open_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_open_attr {
    pub comp_mask: u32,
    pub qp_num: u32,
    pub xrcd: *mut ibv_xrcd,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_ibv_qp_open_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_open_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_open_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_num as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).xrcd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for ibv_qp_open_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(1);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CUR_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(2);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_EN_SQD_ASYNC_NOTIFY: ibv_qp_attr_mask = ibv_qp_attr_mask(4);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ACCESS_FLAGS: ibv_qp_attr_mask = ibv_qp_attr_mask(8);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PKEY_INDEX: ibv_qp_attr_mask = ibv_qp_attr_mask(16);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PORT: ibv_qp_attr_mask = ibv_qp_attr_mask(32);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_QKEY: ibv_qp_attr_mask = ibv_qp_attr_mask(64);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_AV: ibv_qp_attr_mask = ibv_qp_attr_mask(128);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MTU: ibv_qp_attr_mask = ibv_qp_attr_mask(256);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_TIMEOUT: ibv_qp_attr_mask = ibv_qp_attr_mask(512);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RETRY_CNT: ibv_qp_attr_mask = ibv_qp_attr_mask(1024);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RNR_RETRY: ibv_qp_attr_mask = ibv_qp_attr_mask(2048);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(4096);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_QP_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(8192);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ALT_PATH: ibv_qp_attr_mask = ibv_qp_attr_mask(16384);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MIN_RNR_TIMER: ibv_qp_attr_mask = ibv_qp_attr_mask(32768);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_SQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(65536);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_DEST_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(131072);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MIG_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(262144);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CAP: ibv_qp_attr_mask = ibv_qp_attr_mask(524288);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_DEST_QPN: ibv_qp_attr_mask = ibv_qp_attr_mask(1048576);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RATE_LIMIT: ibv_qp_attr_mask = ibv_qp_attr_mask(33554432);
}
impl ::std::ops::BitOr<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ibv_qp_attr_mask(pub u32);
pub mod ibv_qp_state {
    pub type Type = u32;
    pub const IBV_QPS_RESET: Type = 0;
    pub const IBV_QPS_INIT: Type = 1;
    pub const IBV_QPS_RTR: Type = 2;
    pub const IBV_QPS_RTS: Type = 3;
    pub const IBV_QPS_SQD: Type = 4;
    pub const IBV_QPS_SQE: Type = 5;
    pub const IBV_QPS_ERR: Type = 6;
    pub const IBV_QPS_UNKNOWN: Type = 7;
}
pub const IBV_MIG_MIGRATED: ibv_mig_state = 0;
pub const IBV_MIG_REARM: ibv_mig_state = 1;
pub const IBV_MIG_ARMED: ibv_mig_state = 2;
pub type ibv_mig_state = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state::Type,
    pub cur_qp_state: ibv_qp_state::Type,
    pub path_mtu: ibv_mtu,
    pub path_mig_state: ibv_mig_state,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: ::std::os::raw::c_uint,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_attr>(),
        144usize,
        concat!("Size of: ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cur_qp_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cur_qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mig_state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mig_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rq_psn as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_psn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).dest_qp_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(dest_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_access_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_access_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cap as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).ah_attr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_ah_attr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).pkey_index as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_pkey_index as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).en_sqd_async_notify as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(en_sqd_async_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_draining as *const _ as usize },
        125usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_draining)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_rd_atomic as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_dest_rd_atomic as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_dest_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).min_rnr_timer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(min_rnr_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).port_num as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).timeout as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).retry_cnt as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(retry_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rnr_retry as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rnr_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_port_num as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_timeout as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rate_limit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rate_limit)
        )
    );
}
impl Default for ibv_qp_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_qp_rate_limit_attr {
    pub rate_limit: u32,
    pub max_burst_sz: u32,
    pub typical_pkt_sz: u16,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_rate_limit_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_rate_limit_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_rate_limit_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).rate_limit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(rate_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).max_burst_sz as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(max_burst_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).typical_pkt_sz as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(typical_pkt_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).comp_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
pub mod ibv_wr_opcode {
    pub type Type = u32;
    pub const IBV_WR_RDMA_WRITE: Type = 0;
    pub const IBV_WR_RDMA_WRITE_WITH_IMM: Type = 1;
    pub const IBV_WR_SEND: Type = 2;
    pub const IBV_WR_SEND_WITH_IMM: Type = 3;
    pub const IBV_WR_RDMA_READ: Type = 4;
    pub const IBV_WR_ATOMIC_CMP_AND_SWP: Type = 5;
    pub const IBV_WR_ATOMIC_FETCH_AND_ADD: Type = 6;
    pub const IBV_WR_LOCAL_INV: Type = 7;
    pub const IBV_WR_BIND_MW: Type = 8;
    pub const IBV_WR_SEND_WITH_INV: Type = 9;
    pub const IBV_WR_TSO: Type = 10;
}
impl ibv_send_flags {
    pub const IBV_SEND_FENCE: ibv_send_flags = ibv_send_flags(1);
}
impl ibv_send_flags {
    pub const IBV_SEND_SIGNALED: ibv_send_flags = ibv_send_flags(2);
}
impl ibv_send_flags {
    pub const IBV_SEND_SOLICITED: ibv_send_flags = ibv_send_flags(4);
}
impl ibv_send_flags {
    pub const IBV_SEND_INLINE: ibv_send_flags = ibv_send_flags(8);
}
impl ibv_send_flags {
    pub const IBV_SEND_IP_CSUM: ibv_send_flags = ibv_send_flags(16);
}
impl ::std::ops::BitOr<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_send_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_send_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_send_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_send_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_send_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_send_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct ibv_send_flags(pub u32);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_sge() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sge>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_sge))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sge>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).lkey as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(lkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode::Type,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).imm_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).invalidate_rkey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(invalidate_rkey)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).compare_add
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(compare_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).swap as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).rkey as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).ah as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qpn
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qpn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qkey
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qkey)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).rdma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(rdma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(ud)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>())).remote_srqn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(remote_srqn)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3>())).xrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3),
            "::",
            stringify!(xrc)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).mw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(mw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).bind_info
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(bind_info)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).mss as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(mss)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).bind_mw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(tso)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_send_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).sg_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).num_sge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(num_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).opcode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).send_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(send_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).wr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).qp_type as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for ibv_send_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_recv_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_recv_wr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_recv_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).sg_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).num_sge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(num_sge)
        )
    );
}
impl Default for ibv_recv_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_WR_TAG_ADD: ibv_ops_wr_opcode = 0;
pub const IBV_WR_TAG_DEL: ibv_ops_wr_opcode = 1;
pub const IBV_WR_TAG_SYNC: ibv_ops_wr_opcode = 2;
pub type ibv_ops_wr_opcode = u32;
pub const IBV_OPS_SIGNALED: ibv_ops_flags = 1;
pub const IBV_OPS_TM_SYNC: ibv_ops_flags = 2;
pub type ibv_ops_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr {
    pub wr_id: u64,
    pub next: *mut ibv_ops_wr,
    pub opcode: ibv_ops_wr_opcode,
    pub flags: ::std::os::raw::c_int,
    pub tm: ibv_ops_wr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1 {
    pub unexpected_cnt: u32,
    pub handle: u32,
    pub add: ibv_ops_wr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    pub recv_wr_id: u64,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub tag: u64,
    pub mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).recv_wr_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(recv_wr_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).sg_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).num_sge as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(num_sge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).tag as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).mask as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).unexpected_cnt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(unexpected_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(add)
        )
    );
}
impl Default for ibv_ops_wr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_ops_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).opcode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).tm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(tm)
        )
    );
}
impl Default for ibv_ops_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_mw_bind() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw_bind>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw_bind>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).send_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(send_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).bind_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(bind_info)
        )
    );
}
impl Default for ibv_mw_bind {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_srq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).srq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(events_completed)
        )
    );
}
impl Default for ibv_srq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state,
    pub wq_type: ibv_wq_type,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_wq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq>(),
        152usize,
        concat!("Size of: ", stringify!(ibv_wq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_num as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).handle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_type as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).post_recv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).mutex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cond as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).events_completed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).comp_mask as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_wq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state::Type,
    pub qp_type: ibv_qp_type::Type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp>(),
        160usize,
        concat!("Size of: ", stringify!(ibv_qp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).send_cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).recv_cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).srq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).handle as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_num as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_type as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).mutex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).cond as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).events_completed as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(events_completed)
        )
    );
}
impl Default for ibv_qp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_comp_channel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_comp_channel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_comp_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).refcnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for ibv_comp_channel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).async_events_completed as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(async_events_completed)
        )
    );
}
impl Default for ibv_cq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_poll_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_poll_cq_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_poll_cq_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub priv_: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc_tm_info() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc_tm_info>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc_tm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status::Type,
    pub wr_id: u64,
    pub start_poll: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_cq_ex,
            attr: *mut ibv_poll_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_poll: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_int,
    >,
    pub end_poll: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex)>,
    pub read_opcode:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ibv_wc_opcode::Type>,
    pub read_vendor_err:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_byte_len: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_imm_data:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> __be32>,
    pub read_qp_num: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_src_qp: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_wc_flags: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_uint,
    >,
    pub read_slid: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_sl: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_dlid_path_bits:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_completion_ts:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
    pub read_cvlan: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u16>,
    pub read_flow_tag: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_tm_info: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex, tm_info: *mut ibv_wc_tm_info),
    >,
    pub read_completion_wallclock_ns:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
}
#[test]
fn bindgen_test_layout_ibv_cq_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_ex>(),
        288usize,
        concat!("Size of: ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).async_events_completed as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(async_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_mask as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).status as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).wr_id as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).start_poll as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(start_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).next_poll as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(next_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).end_poll as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(end_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_opcode as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_vendor_err as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_vendor_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_byte_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_imm_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_imm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_qp_num as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_src_qp as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_src_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_wc_flags as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_slid as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_sl as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_dlid_path_bits as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_dlid_path_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_ts as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_cvlan as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_cvlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_flow_tag as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_flow_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_tm_info as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_tm_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_wallclock_ns as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_wallclock_ns)
        )
    );
}
impl Default for ibv_cq_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_CQ_ATTR_MODERATE: ibv_cq_attr_mask = 1;
pub const IBV_CQ_ATTR_RESERVED: ibv_cq_attr_mask = 2;
pub type ibv_cq_attr_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_moderate_cq {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_moderate_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_moderate_cq>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_moderate_cq>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_period as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_modify_cq_attr {
    pub attr_mask: u32,
    pub moderate: ibv_moderate_cq,
}
#[test]
fn bindgen_test_layout_ibv_modify_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_modify_cq_attr>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_modify_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).moderate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(moderate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_ah() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ah>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_ah))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ah>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ah))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_ah {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_FLOW_ATTR_FLAGS_ALLOW_LOOP_BACK: ibv_flow_flags = 1;
pub const IBV_FLOW_ATTR_FLAGS_DONT_TRAP: ibv_flow_flags = 2;
pub const IBV_FLOW_ATTR_FLAGS_EGRESS: ibv_flow_flags = 4;
pub type ibv_flow_flags = u32;
pub const IBV_FLOW_ATTR_NORMAL: ibv_flow_attr_type = 0;
pub const IBV_FLOW_ATTR_ALL_DEFAULT: ibv_flow_attr_type = 1;
pub const IBV_FLOW_ATTR_MC_DEFAULT: ibv_flow_attr_type = 2;
pub const IBV_FLOW_ATTR_SNIFFER: ibv_flow_attr_type = 3;
pub type ibv_flow_attr_type = u32;
pub const IBV_FLOW_SPEC_ETH: ibv_flow_spec_type = 32;
pub const IBV_FLOW_SPEC_IPV4: ibv_flow_spec_type = 48;
pub const IBV_FLOW_SPEC_IPV6: ibv_flow_spec_type = 49;
pub const IBV_FLOW_SPEC_IPV4_EXT: ibv_flow_spec_type = 50;
pub const IBV_FLOW_SPEC_ESP: ibv_flow_spec_type = 52;
pub const IBV_FLOW_SPEC_TCP: ibv_flow_spec_type = 64;
pub const IBV_FLOW_SPEC_UDP: ibv_flow_spec_type = 65;
pub const IBV_FLOW_SPEC_VXLAN_TUNNEL: ibv_flow_spec_type = 80;
pub const IBV_FLOW_SPEC_INNER: ibv_flow_spec_type = 256;
pub const IBV_FLOW_SPEC_ACTION_TAG: ibv_flow_spec_type = 4096;
pub const IBV_FLOW_SPEC_ACTION_DROP: ibv_flow_spec_type = 4097;
pub const IBV_FLOW_SPEC_ACTION_HANDLE: ibv_flow_spec_type = 4098;
pub type ibv_flow_spec_type = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_eth_filter {
    pub dst_mac: [u8; 6usize],
    pub src_mac: [u8; 6usize],
    pub ether_type: u16,
    pub vlan_tag: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_eth_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_eth_filter>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_eth_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).dst_mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(dst_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).src_mac as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(src_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).vlan_tag as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(vlan_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_eth {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_eth_filter,
    pub mask: ibv_flow_eth_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_eth() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_eth>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_eth>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).mask as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_eth {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv4_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(dst_ip)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_filter,
    pub mask: ibv_flow_ipv4_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv4_ext_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_ext_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_ext_filter>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_ext_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).proto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).tos as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).ttl as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).flags as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4_ext {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_ext_filter,
    pub mask: ibv_flow_ipv4_ext_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4_ext() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4_ext>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv4_ext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv6_filter {
    pub src_ip: [u8; 16usize],
    pub dst_ip: [u8; 16usize],
    pub flow_label: u32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv6_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv6_filter>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv6_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).flow_label as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).next_hdr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).traffic_class as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).hop_limit as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(hop_limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv6 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv6_filter,
    pub mask: ibv_flow_ipv6_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv6>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv6>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).mask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_esp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_esp_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_esp_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_esp {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_esp_filter,
    pub mask: ibv_flow_esp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_esp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_esp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_esp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_tcp_udp_filter {
    pub dst_port: u16,
    pub src_port: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_tcp_udp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tcp_udp_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tcp_udp_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).dst_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).src_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(src_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tcp_udp {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tcp_udp_filter,
    pub mask: ibv_flow_tcp_udp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tcp_udp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tcp_udp>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tcp_udp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).mask as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_tcp_udp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_tunnel_filter {
    pub tunnel_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_tunnel_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tunnel_filter>())).tunnel_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tunnel_filter),
            "::",
            stringify!(tunnel_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tunnel {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tunnel_filter,
    pub mask: ibv_flow_tunnel_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tunnel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tunnel>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_tunnel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_tag {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub tag_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_tag() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_tag>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).tag_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(tag_id)
        )
    );
}
impl Default for ibv_flow_spec_action_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_drop {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_drop() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_drop>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_drop>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(size)
        )
    );
}
impl Default for ibv_flow_spec_action_drop {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_handle {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub action: *const ibv_flow_action,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_handle() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_handle>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).action as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(action)
        )
    );
}
impl Default for ibv_flow_spec_action_handle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec {
    pub __bindgen_anon_1: ibv_flow_spec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_flow_spec__bindgen_ty_1 {
    pub hdr: ibv_flow_spec__bindgen_ty_1__bindgen_ty_1,
    pub eth: ibv_flow_spec_eth,
    pub ipv4: ibv_flow_spec_ipv4,
    pub tcp_udp: ibv_flow_spec_tcp_udp,
    pub ipv4_ext: ibv_flow_spec_ipv4_ext,
    pub ipv6: ibv_flow_spec_ipv6,
    pub esp: ibv_flow_spec_esp,
    pub tunnel: ibv_flow_spec_tunnel,
    pub flow_tag: ibv_flow_spec_action_tag,
    pub drop: ibv_flow_spec_action_drop,
    pub handle: ibv_flow_spec_action_handle,
    _bindgen_union_align: [u64; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
impl Default for ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).eth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tcp_udp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tcp_udp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4_ext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).esp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tunnel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tunnel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).flow_tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(flow_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).drop as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_flow_spec__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_flow_spec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec))
    );
}
impl Default for ibv_flow_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub type_: ibv_flow_attr_type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).priority as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).num_of_specs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(num_of_specs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).port as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ibv_flow_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_flow_action() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_flow_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_FLOW_ACTION_ESP_MASK_ESN: ibv_flow_action_esp_mask = 1;
pub type ibv_flow_action_esp_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action_esp_attr {
    pub esp_attr: *mut ib_uverbs_flow_action_esp,
    pub keymat_proto: ib_uverbs_flow_action_esp_keymat,
    pub keymat_len: u16,
    pub keymat_ptr: *mut ::std::os::raw::c_void,
    pub replay_proto: ib_uverbs_flow_action_esp_replay,
    pub replay_len: u16,
    pub replay_ptr: *mut ::std::os::raw::c_void,
    pub esp_encap: *mut ib_uverbs_flow_action_esp_encap,
    pub comp_mask: u32,
    pub esn: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_action_esp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action_esp_attr>(),
        56usize,
        concat!("Size of: ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action_esp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_proto as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_proto as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_len as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_ptr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_encap as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_encap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).comp_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esn as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esn)
        )
    );
}
impl Default for ibv_flow_action_esp_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[test]
fn bindgen_test_layout__ibv_device_ops() {
    assert_eq!(
        ::std::mem::size_of::<_ibv_device_ops>(),
        16usize,
        concat!("Size of: ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibv_device_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy2)
        )
    );
}
impl Default for _ibv_device_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_ibv_device() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device>(),
        664usize,
        concat!("Size of: ", stringify!(ibv_device))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>()))._ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).node_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(node_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).transport_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(transport_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_path as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).ibdev_path as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(ibdev_path)
        )
    );
}
impl Default for ibv_device {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_context_ops {
    pub query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub alloc_pd:
        ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context) -> *mut ibv_pd>,
    pub dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> ::std::os::raw::c_int>,
    pub reg_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            addr: *mut ::std::os::raw::c_void,
            length: usize,
            access: ::std::os::raw::c_int,
        ) -> *mut ibv_mr,
    >,
    pub rereg_mr: ::std::option::Option<
        unsafe extern "C" fn(
            mr: *mut ibv_mr,
            flags: ::std::os::raw::c_int,
            pd: *mut ibv_pd,
            addr: *mut ::std::os::raw::c_void,
            length: usize,
            access: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub dereg_mr:
        ::std::option::Option<unsafe extern "C" fn(mr: *mut ibv_mr) -> ::std::os::raw::c_int>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub create_cq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            cqe: ::std::os::raw::c_int,
            channel: *mut ibv_comp_channel,
            comp_vector: ::std::os::raw::c_int,
        ) -> *mut ibv_cq,
    >,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub cq_event: ::std::option::Option<unsafe extern "C" fn(cq: *mut ibv_cq)>,
    pub resize_cq: ::std::option::Option<
        unsafe extern "C" fn(cq: *mut ibv_cq, cqe: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub destroy_cq:
        ::std::option::Option<unsafe extern "C" fn(cq: *mut ibv_cq) -> ::std::os::raw::c_int>,
    pub create_srq: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            srq_init_attr: *mut ibv_srq_init_attr,
        ) -> *mut ibv_srq,
    >,
    pub modify_srq: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            srq_attr: *mut ibv_srq_attr,
            srq_attr_mask: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub query_srq: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            srq_attr: *mut ibv_srq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_srq:
        ::std::option::Option<unsafe extern "C" fn(srq: *mut ibv_srq) -> ::std::os::raw::c_int>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_qp: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, attr: *mut ibv_qp_init_attr) -> *mut ibv_qp,
    >,
    pub query_qp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            attr: *mut ibv_qp_attr,
            attr_mask: ::std::os::raw::c_int,
            init_attr: *mut ibv_qp_init_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub modify_qp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            attr: *mut ibv_qp_attr,
            attr_mask: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_qp:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp) -> ::std::os::raw::c_int>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_ah: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, attr: *mut ibv_ah_attr) -> *mut ibv_ah,
    >,
    pub destroy_ah:
        ::std::option::Option<unsafe extern "C" fn(ah: *mut ibv_ah) -> ::std::os::raw::c_int>,
    pub attach_mcast: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            gid: *const ibv_gid,
            lid: u16,
        ) -> ::std::os::raw::c_int,
    >,
    pub detach_mcast: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            gid: *const ibv_gid,
            lid: u16,
        ) -> ::std::os::raw::c_int,
    >,
    pub async_event: ::std::option::Option<unsafe extern "C" fn(event: *mut ibv_async_event)>,
}
#[test]
fn bindgen_test_layout_ibv_context_ops() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context_ops>(),
        256usize,
        concat!("Size of: ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).query_device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(query_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).query_port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(query_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).alloc_pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(alloc_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).dealloc_pd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(dealloc_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).reg_mr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(reg_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).rereg_mr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(rereg_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).dereg_mr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(dereg_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).alloc_mw as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(alloc_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).bind_mw as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).dealloc_mw as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(dealloc_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).create_cq as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(create_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).poll_cq as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(poll_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).req_notify_cq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(req_notify_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).cq_event as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(cq_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).resize_cq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(resize_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).destroy_cq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(destroy_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).create_srq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(create_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).modify_srq as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(modify_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).query_srq as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(query_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).destroy_srq as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(destroy_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_srq_recv as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_srq_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).create_qp as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(create_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).query_qp as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(query_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).modify_qp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(modify_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).destroy_qp as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(destroy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_send as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_recv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).create_ah as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(create_ah)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).destroy_ah as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(destroy_ah)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).attach_mcast as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(attach_mcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).detach_mcast as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(detach_mcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).async_event as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(async_event)
        )
    );
}
impl Default for ibv_context_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ibv_context() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context>(),
        328usize,
        concat!("Size of: ", stringify!(ibv_context))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).cmd_fd as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(cmd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).async_fd as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(async_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).num_comp_vectors as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(num_comp_vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).mutex as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).abi_compat as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(abi_compat)
        )
    );
}
impl Default for ibv_context {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_CQ_INIT_ATTR_MASK_FLAGS: ibv_cq_init_attr_mask = 1;
pub type ibv_cq_init_attr_mask = u32;
pub const IBV_CREATE_CQ_ATTR_SINGLE_THREADED: ibv_create_cq_attr_flags = 1;
pub type ibv_create_cq_attr_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_init_attr_ex>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cqe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).channel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_vector as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).wc_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ibv_cq_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_parent_domain_init_attr {
    pub pd: *mut ibv_pd,
    pub td: *mut ibv_td,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_parent_domain_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_parent_domain_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_parent_domain_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).td as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_parent_domain_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const IBV_VALUES_MASK_RAW_CLOCK: ibv_values_mask = 1;
pub const IBV_VALUES_MASK_RESERVED: ibv_values_mask = 2;
pub type ibv_values_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: timespec,
}
#[test]
fn bindgen_test_layout_ibv_values_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_values_ex>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_values_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).raw_clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(raw_clock)
        )
    );
}
extern "C" {
    /// ibv_get_device_list - Get list of IB devices currently available
    /// @num_devices: optional.  if non-NULL, set to the number of devices
    /// returned in the array.
    ///
    /// Return a NULL-terminated array of IB devices.  The array can be
    /// released with ibv_free_device_list().
    pub fn ibv_get_device_list(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_device;
}
extern "C" {
    /// ibv_free_device_list - Free list from ibv_get_device_list()
    ///
    /// Free an array of devices returned from ibv_get_device_list().  Once
    /// the array is freed, pointers to devices that were not opened with
    /// ibv_open_device() are no longer valid.  Client code must open all
    /// devices it intends to use before calling ibv_free_device_list().
    pub fn ibv_free_device_list(list: *mut *mut ibv_device);
}
extern "C" {
    /// ibv_get_device_name - Return kernel device name
    pub fn ibv_get_device_name(device: *mut ibv_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// ibv_get_device_guid - Return device's node GUID
    pub fn ibv_get_device_guid(device: *mut ibv_device) -> __be64;
}
extern "C" {
    /// ibv_open_device - Initialize device for use
    pub fn ibv_open_device(device: *mut ibv_device) -> *mut ibv_context;
}
extern "C" {
    /// ibv_close_device - Release device
    pub fn ibv_close_device(context: *mut ibv_context) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_get_async_event - Get next async event
    /// @event: Pointer to use to return async event
    ///
    /// All async events returned by ibv_get_async_event() must eventually
    /// be acknowledged with ibv_ack_async_event().
    pub fn ibv_get_async_event(
        context: *mut ibv_context,
        event: *mut ibv_async_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_ack_async_event - Acknowledge an async event
    /// @event: Event to be acknowledged.
    ///
    /// All async events which are returned by ibv_get_async_event() must
    /// be acknowledged.  To avoid races, destroying an object (CQ, SRQ or
    /// QP) will wait for all affiliated events to be acknowledged, so
    /// there should be a one-to-one correspondence between acks and
    /// successful gets.
    pub fn ibv_ack_async_event(event: *mut ibv_async_event);
}
extern "C" {
    /// ibv_query_device - Get device properties
    pub fn ibv_query_device(
        context: *mut ibv_context,
        device_attr: *mut ibv_device_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_query_port - Get port properties
    pub fn ibv_query_port(
        context: *mut ibv_context,
        port_num: u8,
        port_attr: *mut ibv_port_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_query_gid - Get a GID table entry
    pub fn ibv_query_gid(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        gid: *mut ibv_gid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_query_pkey - Get a P_Key table entry
    pub fn ibv_query_pkey(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        pkey: *mut __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_alloc_pd - Allocate a protection domain
    pub fn ibv_alloc_pd(context: *mut ibv_context) -> *mut ibv_pd;
}
extern "C" {
    /// ibv_dealloc_pd - Free a protection domain
    pub fn ibv_dealloc_pd(pd: *mut ibv_pd) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_reg_mr - Register a memory region
    pub fn ibv_reg_mr(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
pub const IBV_REREG_MR_ERR_INPUT: ibv_rereg_mr_err_code = -1;
pub const IBV_REREG_MR_ERR_DONT_FORK_NEW: ibv_rereg_mr_err_code = -2;
pub const IBV_REREG_MR_ERR_DO_FORK_OLD: ibv_rereg_mr_err_code = -3;
pub const IBV_REREG_MR_ERR_CMD: ibv_rereg_mr_err_code = -4;
pub const IBV_REREG_MR_ERR_CMD_AND_DO_FORK_NEW: ibv_rereg_mr_err_code = -5;
pub type ibv_rereg_mr_err_code = i32;
extern "C" {
    /// ibv_rereg_mr - Re-Register a memory region
    pub fn ibv_rereg_mr(
        mr: *mut ibv_mr,
        flags: ::std::os::raw::c_int,
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        access: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_dereg_mr - Deregister a memory region
    pub fn ibv_dereg_mr(mr: *mut ibv_mr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_create_comp_channel - Create a completion event channel
    pub fn ibv_create_comp_channel(context: *mut ibv_context) -> *mut ibv_comp_channel;
}
extern "C" {
    /// ibv_destroy_comp_channel - Destroy a completion event channel
    pub fn ibv_destroy_comp_channel(channel: *mut ibv_comp_channel) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_create_cq - Create a completion queue
    /// @context - Context CQ will be attached to
    /// @cqe - Minimum number of entries required for CQ
    /// @cq_context - Consumer-supplied context returned for completion events
    /// @channel - Completion channel where completion events will be queued.
    /// May be NULL if completion events will not be used.
    /// @comp_vector - Completion vector used to signal completion events.
    /// Must be >= 0 and < context->num_comp_vectors.
    pub fn ibv_create_cq(
        context: *mut ibv_context,
        cqe: ::std::os::raw::c_int,
        cq_context: *mut ::std::os::raw::c_void,
        channel: *mut ibv_comp_channel,
        comp_vector: ::std::os::raw::c_int,
    ) -> *mut ibv_cq;
}
extern "C" {
    /// ibv_resize_cq - Modifies the capacity of the CQ.
    /// @cq: The CQ to resize.
    /// @cqe: The minimum size of the CQ.
    ///
    /// Users can examine the cq structure to determine the actual CQ size.
    pub fn ibv_resize_cq(cq: *mut ibv_cq, cqe: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_destroy_cq - Destroy a completion queue
    pub fn ibv_destroy_cq(cq: *mut ibv_cq) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_get_cq_event - Read next CQ event
    /// @channel: Channel to get next event from.
    /// @cq: Used to return pointer to CQ.
    /// @cq_context: Used to return consumer-supplied CQ context.
    ///
    /// All completion events returned by ibv_get_cq_event() must
    /// eventually be acknowledged with ibv_ack_cq_events().
    pub fn ibv_get_cq_event(
        channel: *mut ibv_comp_channel,
        cq: *mut *mut ibv_cq,
        cq_context: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_ack_cq_events - Acknowledge CQ completion events
    /// @cq: CQ to acknowledge events for
    /// @nevents: Number of events to acknowledge.
    ///
    /// All completion events which are returned by ibv_get_cq_event() must
    /// be acknowledged.  To avoid races, ibv_destroy_cq() will wait for
    /// all completion events to be acknowledged, so there should be a
    /// one-to-one correspondence between acks and successful gets.  An
    /// application may accumulate multiple completion events and
    /// acknowledge them in a single call to ibv_ack_cq_events() by passing
    /// the number of events to ack in @nevents.
    pub fn ibv_ack_cq_events(cq: *mut ibv_cq, nevents: ::std::os::raw::c_uint);
}
extern "C" {
    /// ibv_create_srq - Creates a SRQ associated with the specified protection
    /// domain.
    /// @pd: The protection domain associated with the SRQ.
    /// @srq_init_attr: A list of initial attributes required to create the SRQ.
    ///
    /// srq_attr->max_wr and srq_attr->max_sge are read the determine the
    /// requested size of the SRQ, and set to the actual values allocated
    /// on return.  If ibv_create_srq() succeeds, then max_wr and max_sge
    /// will always be at least as large as the requested values.
    pub fn ibv_create_srq(pd: *mut ibv_pd, srq_init_attr: *mut ibv_srq_init_attr) -> *mut ibv_srq;
}
extern "C" {
    /// ibv_modify_srq - Modifies the attributes for the specified SRQ.
    /// @srq: The SRQ to modify.
    /// @srq_attr: On input, specifies the SRQ attributes to modify.  On output,
    /// the current values of selected SRQ attributes are returned.
    /// @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ
    /// are being modified.
    ///
    /// The mask may contain IBV_SRQ_MAX_WR to resize the SRQ and/or
    /// IBV_SRQ_LIMIT to set the SRQ's limit and request notification when
    /// the number of receives queued drops below the limit.
    pub fn ibv_modify_srq(
        srq: *mut ibv_srq,
        srq_attr: *mut ibv_srq_attr,
        srq_attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_query_srq - Returns the attribute list and current values for the
    /// specified SRQ.
    /// @srq: The SRQ to query.
    /// @srq_attr: The attributes of the specified SRQ.
    pub fn ibv_query_srq(srq: *mut ibv_srq, srq_attr: *mut ibv_srq_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_destroy_srq - Destroys the specified SRQ.
    /// @srq: The SRQ to destroy.
    pub fn ibv_destroy_srq(srq: *mut ibv_srq) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_create_qp - Create a queue pair.
    pub fn ibv_create_qp(pd: *mut ibv_pd, qp_init_attr: *mut ibv_qp_init_attr) -> *mut ibv_qp;
}
extern "C" {
    /// ibv_modify_qp - Modify a queue pair.
    pub fn ibv_modify_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_query_qp - Returns the attribute list and current values for the
    /// specified QP.
    /// @qp: The QP to query.
    /// @attr: The attributes of the specified QP.
    /// @attr_mask: A bit-mask used to select specific attributes to query.
    /// @init_attr: Additional attributes of the selected QP.
    ///
    /// The qp_attr_mask may be used to limit the query to gathering only the
    /// selected attributes.
    pub fn ibv_query_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
        init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_destroy_qp - Destroy a queue pair.
    pub fn ibv_destroy_qp(qp: *mut ibv_qp) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_create_ah - Create an address handle.
    pub fn ibv_create_ah(pd: *mut ibv_pd, attr: *mut ibv_ah_attr) -> *mut ibv_ah;
}
extern "C" {
    /// ibv_init_ah_from_wc - Initializes address handle attributes from a
    /// work completion.
    /// @context: Device context on which the received message arrived.
    /// @port_num: Port on which the received message arrived.
    /// @wc: Work completion associated with the received message.
    /// @grh: References the received global route header.  This parameter is
    /// ignored unless the work completion indicates that the GRH is valid.
    /// @ah_attr: Returned attributes that can be used when creating an address
    /// handle for replying to the message.
    pub fn ibv_init_ah_from_wc(
        context: *mut ibv_context,
        port_num: u8,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        ah_attr: *mut ibv_ah_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_create_ah_from_wc - Creates an address handle associated with the
    /// sender of the specified work completion.
    /// @pd: The protection domain associated with the address handle.
    /// @wc: Work completion information associated with a received message.
    /// @grh: References the received global route header.  This parameter is
    /// ignored unless the work completion indicates that the GRH is valid.
    /// @port_num: The outbound port number to associate with the address.
    ///
    /// The address handle is used to reference a local or global destination
    /// in all UD QP post sends.
    pub fn ibv_create_ah_from_wc(
        pd: *mut ibv_pd,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        port_num: u8,
    ) -> *mut ibv_ah;
}
extern "C" {
    /// ibv_destroy_ah - Destroy an address handle.
    pub fn ibv_destroy_ah(ah: *mut ibv_ah) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_attach_mcast - Attaches the specified QP to a multicast group.
    /// @qp: QP to attach to the multicast group.  The QP must be a UD QP.
    /// @gid: Multicast group GID.
    /// @lid: Multicast group LID in host byte order.
    ///
    /// In order to route multicast packets correctly, subnet
    /// administration must have created the multicast group and configured
    /// the fabric appropriately.  The port associated with the specified
    /// QP must also be a member of the multicast group.
    pub fn ibv_attach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_detach_mcast - Detaches the specified QP from a multicast group.
    /// @qp: QP to detach from the multicast group.
    /// @gid: Multicast group GID.
    /// @lid: Multicast group LID in host byte order.
    pub fn ibv_detach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_fork_init - Prepare data structures so that fork() may be used
    /// safely.  If this function is not called or returns a non-zero
    /// status, then libibverbs data structures are not fork()-safe and the
    /// effect of an application calling fork() is undefined.
    pub fn ibv_fork_init() -> ::std::os::raw::c_int;
}
extern "C" {
    /// ibv_node_type_str - Return string describing node_type enum value
    pub fn ibv_node_type_str(node_type: ibv_node_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// ibv_port_state_str - Return string describing port_state enum value
    pub fn ibv_port_state_str(port_state: ibv_port_state::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// ibv_event_type_str - Return string describing event_type enum value
    pub fn ibv_event_type_str(event: ibv_event_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_resolve_eth_l2_from_gid(
        context: *mut ibv_context,
        attr: *mut ibv_ah_attr,
        eth_mac: *mut u8,
        vid: *mut u16,
    ) -> ::std::os::raw::c_int;
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_path_rec {
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub raw_traffic: ::std::os::raw::c_int,
    pub flow_label: __be32,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reversible: ::std::os::raw::c_int,
    pub numb_path: u8,
    pub pkey: __be16,
    pub sl: u8,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub preference: u8,
}
#[test]
fn bindgen_test_layout_ibv_sa_path_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_path_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_path_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dlid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).slid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).raw_traffic as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(raw_traffic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).flow_label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).hop_limit as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).traffic_class as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).reversible as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(reversible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).numb_path as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(numb_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).pkey as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu_selector as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate_selector as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time_selector as *const _
                as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).preference as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(preference)
        )
    );
}
impl Default for ibv_sa_path_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_mcmember_rec {
    pub mgid: ibv_gid,
    pub port_gid: ibv_gid,
    pub qkey: u32,
    pub mlid: u16,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub traffic_class: u8,
    pub pkey: u16,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub sl: u8,
    pub flow_label: u32,
    pub hop_limit: u8,
    pub scope: u8,
    pub join_state: u8,
    pub proxy_join: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_sa_mcmember_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_mcmember_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_mcmember_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).port_gid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(port_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).qkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mlid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mlid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu_selector as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).traffic_class as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).pkey as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate_selector as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time_selector as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time as *const _ as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).sl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).flow_label as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).hop_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).scope as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).join_state as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(join_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).proxy_join as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(proxy_join)
        )
    );
}
impl Default for ibv_sa_mcmember_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_service_rec {
    pub id: u64,
    pub gid: ibv_gid,
    pub pkey: u16,
    pub lease: u32,
    pub key: [u8; 16usize],
    pub name: [u8; 64usize],
    pub data8: [u8; 16usize],
    pub data16: [u16; 8usize],
    pub data32: [u32; 4usize],
    pub data64: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ibv_sa_service_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_service_rec>(),
        176usize,
        concat!("Size of: ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_service_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).lease as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(lease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data8 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data16 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data32 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data64 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data64)
        )
    );
}
impl Default for ibv_sa_service_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_record {
    pub service_id: __be64,
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub flowlabel_hoplimit: __be32,
    pub tclass: u8,
    pub reversible_numpath: u8,
    pub pkey: __be16,
    pub qosclass_sl: __be16,
    pub mtu: u8,
    pub rate: u8,
    pub packetlifetime: u8,
    pub preference: u8,
    pub reserved: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ibv_path_record() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_record>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_path_record))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_record>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).service_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).sgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dlid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).slid as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).flowlabel_hoplimit as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(flowlabel_hoplimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).tclass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(tclass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).reversible_numpath as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reversible_numpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).pkey as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).qosclass_sl as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(qosclass_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).mtu as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).rate as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).packetlifetime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(packetlifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).preference as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(preference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).reserved as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for ibv_path_record {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_data {
    pub flags: u32,
    pub reserved: u32,
    pub path: ibv_path_record,
}
#[test]
fn bindgen_test_layout_ibv_path_data() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_data>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_path_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(path)
        )
    );
}
impl Default for ibv_path_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const RDMA_CM_EVENT_ADDR_RESOLVED: rdma_cm_event_type = 0;
pub const RDMA_CM_EVENT_ADDR_ERROR: rdma_cm_event_type = 1;
pub const RDMA_CM_EVENT_ROUTE_RESOLVED: rdma_cm_event_type = 2;
pub const RDMA_CM_EVENT_ROUTE_ERROR: rdma_cm_event_type = 3;
pub const RDMA_CM_EVENT_CONNECT_REQUEST: rdma_cm_event_type = 4;
pub const RDMA_CM_EVENT_CONNECT_RESPONSE: rdma_cm_event_type = 5;
pub const RDMA_CM_EVENT_CONNECT_ERROR: rdma_cm_event_type = 6;
pub const RDMA_CM_EVENT_UNREACHABLE: rdma_cm_event_type = 7;
pub const RDMA_CM_EVENT_REJECTED: rdma_cm_event_type = 8;
pub const RDMA_CM_EVENT_ESTABLISHED: rdma_cm_event_type = 9;
pub const RDMA_CM_EVENT_DISCONNECTED: rdma_cm_event_type = 10;
pub const RDMA_CM_EVENT_DEVICE_REMOVAL: rdma_cm_event_type = 11;
pub const RDMA_CM_EVENT_MULTICAST_JOIN: rdma_cm_event_type = 12;
pub const RDMA_CM_EVENT_MULTICAST_ERROR: rdma_cm_event_type = 13;
pub const RDMA_CM_EVENT_ADDR_CHANGE: rdma_cm_event_type = 14;
pub const RDMA_CM_EVENT_TIMEWAIT_EXIT: rdma_cm_event_type = 15;
pub type rdma_cm_event_type = u32;
pub const RDMA_PS_IPOIB: rdma_port_space = 2;
pub const RDMA_PS_TCP: rdma_port_space = 262;
pub const RDMA_PS_UDP: rdma_port_space = 273;
pub const RDMA_PS_IB: rdma_port_space = 319;
pub type rdma_port_space = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ib_addr {
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
    pub pkey: __be16,
}
#[test]
fn bindgen_test_layout_rdma_ib_addr() {
    assert_eq!(
        ::std::mem::size_of::<rdma_ib_addr>(),
        40usize,
        concat!("Size of: ", stringify!(rdma_ib_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_ib_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_ib_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).sgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).dgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).pkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(pkey)
        )
    );
}
impl Default for rdma_ib_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_addr {
    pub __bindgen_anon_1: rdma_addr__bindgen_ty_1,
    pub __bindgen_anon_2: rdma_addr__bindgen_ty_2,
    pub addr: rdma_addr__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_1 {
    pub src_addr: sockaddr,
    pub src_sin: sockaddr_in,
    pub src_sin6: sockaddr_in6,
    pub src_storage: sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_storage)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_2 {
    pub dst_addr: sockaddr,
    pub dst_sin: sockaddr_in,
    pub dst_sin6: sockaddr_in6,
    pub dst_storage: sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_2>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_storage)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_3 {
    pub ibaddr: rdma_ib_addr,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_3>())).ibaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_3),
            "::",
            stringify!(ibaddr)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rdma_addr() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr>(),
        296usize,
        concat!("Size of: ", stringify!(rdma_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr>())).addr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rdma_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_route {
    pub addr: rdma_addr,
    pub path_rec: *mut ibv_sa_path_rec,
    pub num_paths: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_route() {
    assert_eq!(
        ::std::mem::size_of::<rdma_route>(),
        312usize,
        concat!("Size of: ", stringify!(rdma_route))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_route>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_route))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).path_rec as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(path_rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).num_paths as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(num_paths)
        )
    );
}
impl Default for rdma_route {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rdma_event_channel {
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_event_channel() {
    assert_eq!(
        ::std::mem::size_of::<rdma_event_channel>(),
        4usize,
        concat!("Size of: ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_event_channel>(),
        4usize,
        concat!("Alignment of ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_event_channel>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_event_channel),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_id {
    pub verbs: *mut ibv_context,
    pub channel: *mut rdma_event_channel,
    pub context: *mut ::std::os::raw::c_void,
    pub qp: *mut ibv_qp,
    pub route: rdma_route,
    pub ps: rdma_port_space,
    pub port_num: u8,
    pub event: *mut rdma_cm_event,
    pub send_cq_channel: *mut ibv_comp_channel,
    pub send_cq: *mut ibv_cq,
    pub recv_cq_channel: *mut ibv_comp_channel,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub pd: *mut ibv_pd,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_rdma_cm_id() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_id>(),
        416usize,
        concat!("Size of: ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_id>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).verbs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(verbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).route as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).ps as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).port_num as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).event as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq_channel as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq_channel as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).srq as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).pd as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp_type as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for rdma_cm_id {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_conn_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub responder_resources: u8,
    pub initiator_depth: u8,
    pub flow_control: u8,
    pub retry_count: u8,
    pub rnr_retry_count: u8,
    pub srq: u8,
    pub qp_num: u32,
}
#[test]
fn bindgen_test_layout_rdma_conn_param() {
    assert_eq!(
        ::std::mem::size_of::<rdma_conn_param>(),
        24usize,
        concat!("Size of: ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_conn_param>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).private_data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).responder_resources as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(responder_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).initiator_depth as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(initiator_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).flow_control as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).retry_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).rnr_retry_count as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(rnr_retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).srq as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).qp_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(qp_num)
        )
    );
}
impl Default for rdma_conn_param {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ud_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub ah_attr: ibv_ah_attr,
    pub qp_num: u32,
    pub qkey: u32,
}
#[test]
fn bindgen_test_layout_rdma_ud_param() {
    assert_eq!(
        ::std::mem::size_of::<rdma_ud_param>(),
        56usize,
        concat!("Size of: ", stringify!(rdma_ud_param))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_ud_param>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_ud_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).private_data_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(private_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).ah_attr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).qp_num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).qkey as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(qkey)
        )
    );
}
impl Default for rdma_ud_param {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_event {
    pub id: *mut rdma_cm_id,
    pub listen_id: *mut rdma_cm_id,
    pub event: rdma_cm_event_type,
    pub status: ::std::os::raw::c_int,
    pub param: rdma_cm_event__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_cm_event__bindgen_ty_1 {
    pub conn: rdma_conn_param,
    pub ud: rdma_ud_param,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rdma_cm_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_event__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).conn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(ud)
        )
    );
}
impl Default for rdma_cm_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rdma_cm_event() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_event>(),
        80usize,
        concat!("Size of: ", stringify!(rdma_cm_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).listen_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(listen_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).param as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(param)
        )
    );
}
impl Default for rdma_cm_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_qp_type: ::std::os::raw::c_int,
    pub ai_port_space: ::std::os::raw::c_int,
    pub ai_src_len: socklen_t,
    pub ai_dst_len: socklen_t,
    pub ai_src_addr: *mut sockaddr,
    pub ai_dst_addr: *mut sockaddr,
    pub ai_src_canonname: *mut ::std::os::raw::c_char,
    pub ai_dst_canonname: *mut ::std::os::raw::c_char,
    pub ai_route_len: usize,
    pub ai_route: *mut ::std::os::raw::c_void,
    pub ai_connect_len: usize,
    pub ai_connect: *mut ::std::os::raw::c_void,
    pub ai_next: *mut rdma_addrinfo,
}
#[test]
fn bindgen_test_layout_rdma_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addrinfo>(),
        96usize,
        concat!("Size of: ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_qp_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_port_space as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_port_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_canonname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_canonname as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
impl Default for rdma_addrinfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const RDMA_CM_JOIN_MC_ATTR_ADDRESS: rdma_cm_join_mc_attr_mask = 1;
pub const RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS: rdma_cm_join_mc_attr_mask = 2;
pub const RDMA_CM_JOIN_MC_ATTR_RESERVED: rdma_cm_join_mc_attr_mask = 4;
pub type rdma_cm_join_mc_attr_mask = u32;
pub const RDMA_MC_JOIN_FLAG_FULLMEMBER: rdma_cm_mc_join_flags = 0;
pub const RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER: rdma_cm_mc_join_flags = 1;
pub const RDMA_MC_JOIN_FLAG_RESERVED: rdma_cm_mc_join_flags = 2;
pub type rdma_cm_mc_join_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_cm_join_mc_attr_ex {
    pub comp_mask: u32,
    pub join_flags: u32,
    pub addr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_rdma_cm_join_mc_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_join_mc_attr_ex>(),
        16usize,
        concat!("Size of: ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_join_mc_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).join_flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(join_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rdma_cm_join_mc_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// rdma_create_event_channel - Open a channel used to report communication events.
    /// Description:
    /// Asynchronous events are reported to users through event channels.  Each
    /// event channel maps to a file descriptor.
    /// Notes:
    /// All created event channels must be destroyed by calling
    /// rdma_destroy_event_channel.  Users should call rdma_get_cm_event to
    /// retrieve events on an event channel.
    /// See also:
    /// rdma_get_cm_event, rdma_destroy_event_channel
    pub fn rdma_create_event_channel() -> *mut rdma_event_channel;
}
extern "C" {
    /// rdma_destroy_event_channel - Close an event communication channel.
    /// @channel: The communication channel to destroy.
    /// Description:
    /// Release all resources associated with an event channel and closes the
    /// associated file descriptor.
    /// Notes:
    /// All rdma_cm_id's associated with the event channel must be destroyed,
    /// and all returned events must be acked before calling this function.
    /// See also:
    /// rdma_create_event_channel, rdma_get_cm_event, rdma_ack_cm_event
    pub fn rdma_destroy_event_channel(channel: *mut rdma_event_channel);
}
extern "C" {
    /// rdma_create_id - Allocate a communication identifier.
    /// @channel: The communication channel that events associated with the
    /// allocated rdma_cm_id will be reported on.
    /// @id: A reference where the allocated communication identifier will be
    /// returned.
    /// @context: User specified context associated with the rdma_cm_id.
    /// @ps: RDMA port space.
    /// Description:
    /// Creates an identifier that is used to track communication information.
    /// Notes:
    /// Rdma_cm_id's are conceptually equivalent to a socket for RDMA
    /// communication.  The difference is that RDMA communication requires
    /// explicitly binding to a specified RDMA device before communication
    /// can occur, and most operations are asynchronous in nature.  Communication
    /// events on an rdma_cm_id are reported through the associated event
    /// channel.  Users must release the rdma_cm_id by calling rdma_destroy_id.
    /// See also:
    /// rdma_create_event_channel, rdma_destroy_id, rdma_get_devices,
    /// rdma_bind_addr, rdma_resolve_addr, rdma_connect, rdma_listen,
    pub fn rdma_create_id(
        channel: *mut rdma_event_channel,
        id: *mut *mut rdma_cm_id,
        context: *mut ::std::os::raw::c_void,
        ps: rdma_port_space,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_create_ep - Allocate a communication identifier and qp.
    /// @id: A reference where the allocated communication identifier will be
    /// returned.
    /// @res: Result from rdma_getaddrinfo, which specifies the source and
    /// destination addresses, plus optional routing and connection information.
    /// @pd: Optional protection domain.  This parameter is ignored if qp_init_attr
    /// is NULL.
    /// @qp_init_attr: Optional attributes for a QP created on the rdma_cm_id.
    /// Description:
    /// Create an identifier and option QP used for communication.
    /// Notes:
    /// If qp_init_attr is provided, then a queue pair will be allocated and
    /// associated with the rdma_cm_id.  If a pd is provided, the QP will be
    /// created on that PD.  Otherwise, the QP will be allocated on a default
    /// PD.
    /// The rdma_cm_id will be set to use synchronous operations (connect,
    /// listen, and get_request).  To convert to asynchronous operation, the
    /// rdma_cm_id should be migrated to a user allocated event channel.
    /// See also:
    /// rdma_create_id, rdma_create_qp, rdma_migrate_id, rdma_connect,
    /// rdma_listen
    pub fn rdma_create_ep(
        id: *mut *mut rdma_cm_id,
        res: *mut rdma_addrinfo,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_destroy_ep - Deallocates a communication identifier and qp.
    /// @id: The communication identifier to destroy.
    /// Description:
    /// Destroys the specified rdma_cm_id and any associated QP created
    /// on that id.
    /// See also:
    /// rdma_create_ep
    pub fn rdma_destroy_ep(id: *mut rdma_cm_id);
}
extern "C" {
    /// rdma_destroy_id - Release a communication identifier.
    /// @id: The communication identifier to destroy.
    /// Description:
    /// Destroys the specified rdma_cm_id and cancels any outstanding
    /// asynchronous operation.
    /// Notes:
    /// Users must free any associated QP with the rdma_cm_id before
    /// calling this routine and ack an related events.
    /// See also:
    /// rdma_create_id, rdma_destroy_qp, rdma_ack_cm_event
    pub fn rdma_destroy_id(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_bind_addr - Bind an RDMA identifier to a source address.
    /// @id: RDMA identifier.
    /// @addr: Local address information.  Wildcard values are permitted.
    /// Description:
    /// Associates a source address with an rdma_cm_id.  The address may be
    /// wildcarded.  If binding to a specific local address, the rdma_cm_id
    /// will also be bound to a local RDMA device.
    /// Notes:
    /// Typically, this routine is called before calling rdma_listen to bind
    /// to a specific port number, but it may also be called on the active side
    /// of a connection before calling rdma_resolve_addr to bind to a specific
    /// address.
    /// See also:
    /// rdma_create_id, rdma_listen, rdma_resolve_addr, rdma_create_qp
    pub fn rdma_bind_addr(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_resolve_addr - Resolve destination and optional source addresses.
    /// @id: RDMA identifier.
    /// @src_addr: Source address information.  This parameter may be NULL.
    /// @dst_addr: Destination address information.
    /// @timeout_ms: Time to wait for resolution to complete.
    /// Description:
    /// Resolve destination and optional source addresses from IP addresses
    /// to an RDMA address.  If successful, the specified rdma_cm_id will
    /// be bound to a local device.
    /// Notes:
    /// This call is used to map a given destination IP address to a usable RDMA
    /// address.  If a source address is given, the rdma_cm_id is bound to that
    /// address, the same as if rdma_bind_addr were called.  If no source
    /// address is given, and the rdma_cm_id has not yet been bound to a device,
    /// then the rdma_cm_id will be bound to a source address based on the
    /// local routing tables.  After this call, the rdma_cm_id will be bound to
    /// an RDMA device.  This call is typically made from the active side of a
    /// connection before calling rdma_resolve_route and rdma_connect.
    /// See also:
    /// rdma_create_id, rdma_resolve_route, rdma_connect, rdma_create_qp,
    /// rdma_get_cm_event, rdma_bind_addr
    pub fn rdma_resolve_addr(
        id: *mut rdma_cm_id,
        src_addr: *mut sockaddr,
        dst_addr: *mut sockaddr,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_resolve_route - Resolve the route information needed to establish a connection.
    /// @id: RDMA identifier.
    /// @timeout_ms: Time to wait for resolution to complete.
    /// Description:
    /// Resolves an RDMA route to the destination address in order to establish
    /// a connection.  The destination address must have already been resolved
    /// by calling rdma_resolve_addr.
    /// Notes:
    /// This is called on the client side of a connection after calling
    /// rdma_resolve_addr, but before calling rdma_connect.
    /// See also:
    /// rdma_resolve_addr, rdma_connect, rdma_get_cm_event
    pub fn rdma_resolve_route(
        id: *mut rdma_cm_id,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_create_qp - Allocate a QP.
    /// @id: RDMA identifier.
    /// @pd: Optional protection domain for the QP.
    /// @qp_init_attr: initial QP attributes.
    /// Description:
    /// Allocate a QP associated with the specified rdma_cm_id and transition it
    /// for sending and receiving.
    /// Notes:
    /// The rdma_cm_id must be bound to a local RDMA device before calling this
    /// function, and the protection domain must be for that same device.
    /// QPs allocated to an rdma_cm_id are automatically transitioned by the
    /// librdmacm through their states.  After being allocated, the QP will be
    /// ready to handle posting of receives.  If the QP is unconnected, it will
    /// be ready to post sends.
    /// If pd is NULL, then the QP will be allocated using a default protection
    /// domain associated with the underlying RDMA device.
    /// See also:
    /// rdma_bind_addr, rdma_resolve_addr, rdma_destroy_qp, ibv_create_qp,
    /// ibv_modify_qp
    pub fn rdma_create_qp(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_qp_ex(
        id: *mut rdma_cm_id,
        qp_init_attr: *mut ibv_qp_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_destroy_qp - Deallocate a QP.
    /// @id: RDMA identifier.
    /// Description:
    /// Destroy a QP allocated on the rdma_cm_id.
    /// Notes:
    /// Users must destroy any QP associated with an rdma_cm_id before
    /// destroying the ID.
    /// See also:
    /// rdma_create_qp, rdma_destroy_id, ibv_destroy_qp
    pub fn rdma_destroy_qp(id: *mut rdma_cm_id);
}
extern "C" {
    /// rdma_connect - Initiate an active connection request.
    /// @id: RDMA identifier.
    /// @conn_param: optional connection parameters.
    /// Description:
    /// For a connected rdma_cm_id, this call initiates a connection request
    /// to a remote destination.  For an unconnected rdma_cm_id, it initiates
    /// a lookup of the remote QP providing the datagram service.
    /// Notes:
    /// Users must have resolved a route to the destination address
    /// by having called rdma_resolve_route before calling this routine.
    /// A user may override the default connection parameters and exchange
    /// private data as part of the connection by using the conn_param parameter.
    /// See also:
    /// rdma_resolve_route, rdma_disconnect, rdma_listen, rdma_get_cm_event
    pub fn rdma_connect(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_listen - Listen for incoming connection requests.
    /// @id: RDMA identifier.
    /// @backlog: backlog of incoming connection requests.
    /// Description:
    /// Initiates a listen for incoming connection requests or datagram service
    /// lookup.  The listen will be restricted to the locally bound source
    /// address.
    /// Notes:
    /// Users must have bound the rdma_cm_id to a local address by calling
    /// rdma_bind_addr before calling this routine.  If the rdma_cm_id is
    /// bound to a specific IP address, the listen will be restricted to that
    /// address and the associated RDMA device.  If the rdma_cm_id is bound
    /// to an RDMA port number only, the listen will occur across all RDMA
    /// devices.
    /// See also:
    /// rdma_bind_addr, rdma_connect, rdma_accept, rdma_reject, rdma_get_cm_event
    pub fn rdma_listen(
        id: *mut rdma_cm_id,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_get_request
    pub fn rdma_get_request(
        listen: *mut rdma_cm_id,
        id: *mut *mut rdma_cm_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_accept - Called to accept a connection request.
    /// @id: Connection identifier associated with the request.
    /// @conn_param: Optional information needed to establish the connection.
    /// Description:
    /// Called from the listening side to accept a connection or datagram
    /// service lookup request.
    /// Notes:
    /// Unlike the socket accept routine, rdma_accept is not called on a
    /// listening rdma_cm_id.  Instead, after calling rdma_listen, the user
    /// waits for a connection request event to occur.  Connection request
    /// events give the user a newly created rdma_cm_id, similar to a new
    /// socket, but the rdma_cm_id is bound to a specific RDMA device.
    /// rdma_accept is called on the new rdma_cm_id.
    /// A user may override the default connection parameters and exchange
    /// private data as part of the connection by using the conn_param parameter.
    /// See also:
    /// rdma_listen, rdma_reject, rdma_get_cm_event
    pub fn rdma_accept(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_reject - Called to reject a connection request.
    /// @id: Connection identifier associated with the request.
    /// @private_data: Optional private data to send with the reject message.
    /// @private_data_len: Size of the private_data to send, in bytes.
    /// Description:
    /// Called from the listening side to reject a connection or datagram
    /// service lookup request.
    /// Notes:
    /// After receiving a connection request event, a user may call rdma_reject
    /// to reject the request.  If the underlying RDMA transport supports
    /// private data in the reject message, the specified data will be passed to
    /// the remote side.
    /// See also:
    /// rdma_listen, rdma_accept, rdma_get_cm_event
    pub fn rdma_reject(
        id: *mut rdma_cm_id,
        private_data: *const ::std::os::raw::c_void,
        private_data_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_notify - Notifies the librdmacm of an asynchronous event.
    /// @id: RDMA identifier.
    /// @event: Asynchronous event.
    /// Description:
    /// Used to notify the librdmacm of asynchronous events that have occurred
    /// on a QP associated with the rdma_cm_id.
    /// Notes:
    /// Asynchronous events that occur on a QP are reported through the user's
    /// device event handler.  This routine is used to notify the librdmacm of
    /// communication events.  In most cases, use of this routine is not
    /// necessary, however if connection establishment is done out of band
    /// (such as done through Infiniband), it's possible to receive data on a
    /// QP that is not yet considered connected.  This routine forces the
    /// connection into an established state in this case in order to handle
    /// the rare situation where the connection never forms on its own.
    /// Events that should be reported to the CM are: IB_EVENT_COMM_EST.
    /// See also:
    /// rdma_connect, rdma_accept, rdma_listen
    pub fn rdma_notify(id: *mut rdma_cm_id, event: ibv_event_type) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_disconnect - This function disconnects a connection.
    /// @id: RDMA identifier.
    /// Description:
    /// Disconnects a connection and transitions any associated QP to the
    /// error state.
    /// See also:
    /// rdma_connect, rdma_listen, rdma_accept
    pub fn rdma_disconnect(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_join_multicast - Joins a multicast group.
    /// @id: Communication identifier associated with the request.
    /// @addr: Multicast address identifying the group to join.
    /// @context: User-defined context associated with the join request.
    /// Description:
    /// Joins a multicast group and attaches an associated QP to the group.
    /// Notes:
    /// Before joining a multicast group, the rdma_cm_id must be bound to
    /// an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of
    /// rdma_resolve_addr requires the local routing tables to resolve the
    /// multicast address to an RDMA device.  The user must call
    /// rdma_leave_multicast to leave the multicast group and release any
    /// multicast resources.  The context is returned to the user through
    /// the private_data field in the rdma_cm_event.
    /// See also:
    /// rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp
    pub fn rdma_join_multicast(
        id: *mut rdma_cm_id,
        addr: *mut sockaddr,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_leave_multicast - Leaves a multicast group.
    /// @id: Communication identifier associated with the request.
    /// @addr: Multicast address identifying the group to leave.
    /// Description:
    /// Leaves a multicast group and detaches an associated QP from the group.
    /// Notes:
    /// Calling this function before a group has been fully joined results in
    /// canceling the join operation.  Users should be aware that messages
    /// received from the multicast group may stilled be queued for
    /// completion processing immediately after leaving a multicast group.
    /// Destroying an rdma_cm_id will automatically leave all multicast groups.
    /// See also:
    /// rdma_join_multicast, rdma_destroy_qp
    pub fn rdma_leave_multicast(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_multicast_ex - Joins a multicast group with options.
    /// @id: Communication identifier associated with the request.
    /// @mc_join_attr: Extensive struct containing multicast join parameters.
    /// @context: User-defined context associated with the join request.
    /// Description:
    /// Joins a multicast group with options. Currently supporting MC join flags.
    /// The QP will be attached based on the given join flag.
    /// Join message will be sent according to the join flag.
    /// Notes:
    /// Before joining a multicast group, the rdma_cm_id must be bound to
    /// an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of
    /// rdma_resolve_addr requires the local routing tables to resolve the
    /// multicast address to an RDMA device.  The user must call
    /// rdma_leave_multicast to leave the multicast group and release any
    /// multicast resources.  The context is returned to the user through
    /// the private_data field in the rdma_cm_event.
    /// See also:
    /// rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp
    pub fn rdma_join_multicast_ex(
        id: *mut rdma_cm_id,
        mc_join_attr: *mut rdma_cm_join_mc_attr_ex,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_get_cm_event - Retrieves the next pending communication event.
    /// @channel: Event channel to check for events.
    /// @event: Allocated information about the next communication event.
    /// Description:
    /// Retrieves a communication event.  If no events are pending, by default,
    /// the call will block until an event is received.
    /// Notes:
    /// The default synchronous behavior of this routine can be changed by
    /// modifying the file descriptor associated with the given channel.  All
    /// events that are reported must be acknowledged by calling rdma_ack_cm_event.
    /// Destruction of an rdma_cm_id will block until related events have been
    /// acknowledged.
    /// See also:
    /// rdma_ack_cm_event, rdma_create_event_channel, rdma_event_str
    pub fn rdma_get_cm_event(
        channel: *mut rdma_event_channel,
        event: *mut *mut rdma_cm_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_ack_cm_event - Free a communication event.
    /// @event: Event to be released.
    /// Description:
    /// All events which are allocated by rdma_get_cm_event must be released,
    /// there should be a one-to-one correspondence between successful gets
    /// and acks.
    /// See also:
    /// rdma_get_cm_event, rdma_destroy_id
    pub fn rdma_ack_cm_event(event: *mut rdma_cm_event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_src_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    pub fn rdma_get_dst_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    /// rdma_get_devices - Get list of RDMA devices currently available.
    /// @num_devices: If non-NULL, set to the number of devices returned.
    /// Description:
    /// Return a NULL-terminated array of opened RDMA devices.  Callers can use
    /// this routine to allocate resources on specific RDMA devices that will be
    /// shared across multiple rdma_cm_id's.
    /// Notes:
    /// The returned array must be released by calling rdma_free_devices.  Devices
    /// remain opened while the librdmacm is loaded.
    /// See also:
    /// rdma_free_devices
    pub fn rdma_get_devices(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_context;
}
extern "C" {
    /// rdma_free_devices - Frees the list of devices returned by rdma_get_devices.
    /// @list: List of devices returned from rdma_get_devices.
    /// Description:
    /// Frees the device array returned by rdma_get_devices.
    /// See also:
    /// rdma_get_devices
    pub fn rdma_free_devices(list: *mut *mut ibv_context);
}
extern "C" {
    /// rdma_event_str - Returns a string representation of an rdma cm event.
    /// @event: Asynchronous event.
    /// Description:
    /// Returns a string representation of an asynchronous event.
    /// See also:
    /// rdma_get_cm_event
    pub fn rdma_event_str(event: rdma_cm_event_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// rdma_set_option - Set options for an rdma_cm_id.
    /// @id: Communication identifier to set option for.
    /// @level: Protocol level of the option to set.
    /// @optname: Name of the option to set.
    /// @optval: Reference to the option data.
    /// @optlen: The size of the %optval buffer.
    pub fn rdma_set_option(
        id: *mut rdma_cm_id,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_migrate_id - Move an rdma_cm_id to a new event channel.
    /// @id: Communication identifier to migrate.
    /// @channel: New event channel for rdma_cm_id events.
    pub fn rdma_migrate_id(
        id: *mut rdma_cm_id,
        channel: *mut rdma_event_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// rdma_getaddrinfo - RDMA address and route resolution service.
    pub fn rdma_getaddrinfo(
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const rdma_addrinfo,
        res: *mut *mut rdma_addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_freeaddrinfo(res: *mut rdma_addrinfo);
}
